<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Level.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jpacman-framework</a> &gt; <a href="index.source.html" class="el_package">nl.tudelft.jpacman.level</a> &gt; <span class="el_source">Level.java</span></div><h1>Level.java</h1><pre class="source lang-java linenums">package nl.tudelft.jpacman.level;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import nl.tudelft.jpacman.board.Board;
import nl.tudelft.jpacman.board.Direction;
import nl.tudelft.jpacman.board.Square;
import nl.tudelft.jpacman.board.Unit;
import nl.tudelft.jpacman.npc.Ghost;

/**
 * A level of Pac-Man. A level consists of the board with the players and the
 * AIs on it.
 *
 * @author Jeroen Roosen 
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">@SuppressWarnings(&quot;PMD.TooManyMethods&quot;)</span>
public class Level {

    /**
     * The board of this level.
     */
    private final Board board;

    /**
     * The lock that ensures moves are executed sequential.
     */
<span class="fc" id="L37">    private final Object moveLock = new Object();</span>

    /**
     * The lock that ensures starting and stopping can't interfere with each
     * other.
     */
<span class="fc" id="L43">    private final Object startStopLock = new Object();</span>

    /**
     * The NPCs of this level and, if they are running, their schedules.
     */
    private final Map&lt;Ghost, ScheduledExecutorService&gt; npcs;

    /**
     * &lt;code&gt;true&lt;/code&gt; iff this level is currently in progress, i.e. players
     * and NPCs can move.
     */
    private boolean inProgress;
    
    /**
     * &lt;code&gt;true&lt;/code&gt; iff this level is currently freezed, i.e. NPCs cannot
     * move.
     */
    private boolean isFreezed;

    /**
     * The squares from which players can start this game.
     */
    private final List&lt;Square&gt; startSquares;

    /**
     * The start current selected starting square.
     */
    private int startSquareIndex;

    /**
     * The players on this level.
     */
    private final List&lt;Player&gt; players;

    /**
     * The table of possible collisions between units.
     */
    private final CollisionMap collisions;

    /**
     * The objects observing this level.
     */
    private final Set&lt;LevelObserver&gt; observers;

    /**
     * Creates a new level for the board.
     *
     * @param board
     *            The board for the level.
     * @param ghosts
     *            The ghosts on the board.
     * @param startPositions
     *            The squares on which players start on this board.
     * @param collisionMap
     *            The collection of collisions that should be handled.
     */
    public Level(Board board, List&lt;Ghost&gt; ghosts, List&lt;Square&gt; startPositions,
<span class="fc" id="L100">                 CollisionMap collisionMap) {</span>
<span class="pc bpc" id="L101" title="2 of 4 branches missed.">        assert board != null;</span>
<span class="pc bpc" id="L102" title="2 of 4 branches missed.">        assert ghosts != null;</span>
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">        assert startPositions != null;</span>

<span class="fc" id="L105">        this.board = board;</span>
<span class="fc" id="L106">        this.inProgress = false;</span>
<span class="fc" id="L107">        this.isFreezed = false;	//Added for freeze/unfreeze implementation</span>
<span class="fc" id="L108">        this.npcs = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        for (Ghost ghost : ghosts) {</span>
<span class="fc" id="L110">            npcs.put(ghost, null);</span>
<span class="fc" id="L111">        }</span>
<span class="fc" id="L112">        this.startSquares = startPositions;</span>
<span class="fc" id="L113">        this.startSquareIndex = 0;</span>
<span class="fc" id="L114">        this.players = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L115">        this.collisions = collisionMap;</span>
<span class="fc" id="L116">        this.observers = new HashSet&lt;&gt;();</span>
<span class="fc" id="L117">    }</span>

    /**
     * Adds an observer that will be notified when the level is won or lost.
     *
     * @param observer
     *            The observer that will be notified.
     */
    public void addObserver(LevelObserver observer) {
<span class="fc" id="L126">        observers.add(observer);</span>
<span class="fc" id="L127">    }</span>

    /**
     * Removes an observer if it was listed.
     *
     * @param observer
     *            The observer to be removed.
     */
    public void removeObserver(LevelObserver observer) {
<span class="nc" id="L136">        observers.remove(observer);</span>
<span class="nc" id="L137">    }</span>

    /**
     * Registers a player on this level, assigning him to a starting position. A
     * player can only be registered once, registering a player again will have
     * no effect.
     *
     * @param player
     *            The player to register.
     */
    public void registerPlayer(Player player) {
<span class="pc bpc" id="L148" title="2 of 4 branches missed.">        assert player != null;</span>
<span class="pc bpc" id="L149" title="2 of 4 branches missed.">        assert !startSquares.isEmpty();</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (players.contains(player)) {</span>
<span class="fc" id="L152">            return;</span>
        }
<span class="fc" id="L154">        players.add(player);</span>
<span class="fc" id="L155">        Square square = startSquares.get(startSquareIndex);</span>
<span class="fc" id="L156">        player.occupy(square);</span>
<span class="fc" id="L157">        startSquareIndex++;</span>
<span class="fc" id="L158">        startSquareIndex %= startSquares.size();</span>
<span class="fc" id="L159">    }</span>

    /**
     * Returns the board of this level.
     *
     * @return The board of this level.
     */
    public Board getBoard() {
<span class="fc" id="L167">        return board;</span>
    }

    /**
     * Moves the unit into the given direction if possible and handles all
     * collisions.
     *
     * @param unit
     *            The unit to move.
     * @param direction
     *            The direction to move the unit in.
     */
    public void move(Unit unit, Direction direction) {
<span class="pc bpc" id="L180" title="2 of 4 branches missed.">        assert unit != null;</span>
<span class="pc bpc" id="L181" title="2 of 4 branches missed.">        assert direction != null;</span>
<span class="pc bpc" id="L182" title="2 of 4 branches missed.">        assert unit.hasSquare();</span>

<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (!isInProgress()) {</span>
<span class="nc" id="L185">            return;</span>
        }

<span class="fc" id="L188">        synchronized (moveLock) {</span>
<span class="fc" id="L189">            unit.setDirection(direction);</span>
<span class="fc" id="L190">            Square location = unit.getSquare();</span>
<span class="fc" id="L191">            Square destination = location.getSquareAt(direction);</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">            if (destination.isAccessibleTo(unit)) {</span>
<span class="fc" id="L194">                List&lt;Unit&gt; occupants = destination.getOccupants();</span>
<span class="fc" id="L195">                unit.occupy(destination);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                for (Unit occupant : occupants) {</span>
<span class="fc" id="L197">                    collisions.collide(unit, occupant);</span>
<span class="fc" id="L198">                }</span>
            }
<span class="fc" id="L200">            updateObservers();</span>
<span class="fc" id="L201">        }</span>
<span class="fc" id="L202">    }</span>

    /**
     * Starts or resumes this level, allowing movement and (re)starting the
     * NPCs.
     */
    public void start() {
<span class="fc" id="L209">        synchronized (startStopLock) {</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">            if (isInProgress()) {</span>
<span class="nc" id="L211">                return;</span>
            }
<span class="fc bfc" id="L213" title="All 2 branches covered.">            if (!isFreezed) {	//So that it does not interfere freeze/unfreeze</span>
<span class="fc" id="L214">            	startNPCs();</span>
            }
<span class="fc" id="L216">            inProgress = true;</span>
<span class="fc" id="L217">            updateObservers();</span>
<span class="fc" id="L218">        }</span>
<span class="fc" id="L219">    }</span>

    /**
     * Stops or pauses this level, no longer allowing any movement on the board
     * and stopping all NPCs.
     */
    public void stop() {
<span class="fc" id="L226">        synchronized (startStopLock) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (!isInProgress()) {</span>
<span class="fc" id="L228">                return;</span>
            }
<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (!isFreezed) {	//So that it does not interfere freeze/unfreeze</span>
<span class="fc" id="L231">            	stopNPCs();</span>
            }
<span class="fc" id="L233">            inProgress = false;</span>
<span class="fc" id="L234">        }</span>
<span class="fc" id="L235">    }</span>

    /**
     * Starts all NPC movement scheduling.
     */
    private void startNPCs() {
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (final Ghost npc : npcs.keySet()) {</span>
<span class="fc" id="L242">            ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();</span>

<span class="fc" id="L244">            service.schedule(new NpcMoveTask(service, npc),</span>
<span class="fc" id="L245">                npc.getInterval() / 2, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L247">            npcs.put(npc, service);</span>
<span class="fc" id="L248">        }</span>
<span class="fc" id="L249">    }</span>

    /**
     * Stops all NPC movement scheduling and interrupts any movements being
     * executed.
     */
    private void stopNPCs() {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (Entry&lt;Ghost, ScheduledExecutorService&gt; entry : npcs.entrySet()) {</span>
<span class="fc" id="L257">            ScheduledExecutorService schedule = entry.getValue();</span>
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">            assert schedule != null;</span>
<span class="fc" id="L259">            schedule.shutdownNow();</span>
<span class="fc" id="L260">        }</span>
<span class="fc" id="L261">    }</span>
    
    /**
     * Freeze/Unfreeze all NPCs.
     */
    public void freezeUnfreeze() {
<span class="fc bfc" id="L267" title="All 2 branches covered.">    	if (isInProgress()) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">    		if (!isFreezed) {</span>
<span class="fc" id="L269">        		stopNPCs();</span>
<span class="fc" id="L270">        		isFreezed = true;</span>
            }
        	else {
<span class="fc" id="L273">        		startNPCs();</span>
<span class="fc" id="L274">        		isFreezed = false;</span>
        	}
    	}
<span class="fc" id="L277">    }</span>
    
    /**
     * Returns whether this level is freezed.
     *
     * @return &lt;code&gt;true&lt;/code&gt; iff this level is freezed.
     */
    public boolean isFreezed() {
<span class="fc" id="L285">        return isFreezed;</span>
    }
    
    /**
     * Returns whether NPC's are stopped or not.
     *
     * @return &lt;code&gt;true&lt;/code&gt; iff NPC's are stopped.
     */
    public boolean areNpcsStopped() {
<span class="fc bfc" id="L294" title="All 2 branches covered.">    	for (Entry&lt;Ghost, ScheduledExecutorService&gt; entry : npcs.entrySet()) {</span>
<span class="fc" id="L295">            ScheduledExecutorService schedule = entry.getValue();</span>
<span class="pc bpc" id="L296" title="2 of 4 branches missed.">            assert schedule != null;</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            if (!schedule.isShutdown()) {</span>
<span class="fc" id="L298">            	return false;</span>
            }
<span class="fc" id="L300">        }</span>
<span class="fc" id="L301">    	return true;</span>
    }

    /**
     * Returns whether this level is in progress, i.e. whether moves can be made
     * on the board.
     *
     * @return &lt;code&gt;true&lt;/code&gt; iff this level is in progress.
     */
    public boolean isInProgress() {
<span class="fc" id="L311">        return inProgress;</span>
    }

    /**
     * Updates the observers about the state of this level.
     */
    private void updateObservers() {
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (!isAnyPlayerAlive()) {</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            for (LevelObserver observer : observers) {</span>
<span class="fc" id="L320">                observer.levelLost();</span>
<span class="fc" id="L321">            }</span>
        }
<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (remainingPellets() == 0) {</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">            for (LevelObserver observer : observers) {</span>
<span class="nc" id="L325">                observer.levelWon();</span>
<span class="nc" id="L326">            }</span>
        }
<span class="fc" id="L328">    }</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; iff at least one of the players in this level
     * is alive.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if at least one of the registered players is
     *         alive.
     */
    public boolean isAnyPlayerAlive() {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (Player player : players) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (player.isAlive()) {</span>
<span class="fc" id="L340">                return true;</span>
            }
<span class="fc" id="L342">        }</span>
<span class="fc" id="L343">        return false;</span>
    }

    /**
     * Counts the pellets remaining on the board.
     *
     * @return The amount of pellets remaining on the board.
     */
    public int remainingPellets() {
<span class="fc" id="L352">        Board board = getBoard();</span>
<span class="fc" id="L353">        int pellets = 0;</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (int x = 0; x &lt; board.getWidth(); x++) {</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">            for (int y = 0; y &lt; board.getHeight(); y++) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                for (Unit unit : board.squareAt(x, y).getOccupants()) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">                    if (unit instanceof Pellet) {</span>
<span class="fc" id="L358">                        pellets++;</span>
                    }
<span class="fc" id="L360">                }</span>
            }
        }
<span class="pc bpc" id="L363" title="2 of 4 branches missed.">        assert pellets &gt;= 0;</span>
<span class="fc" id="L364">        return pellets;</span>
    }

    /**
     * A task that moves an NPC and reschedules itself after it finished.
     *
     * @author Jeroen Roosen
     */
    private final class NpcMoveTask implements Runnable {

        /**
         * The service executing the task.
         */
        private final ScheduledExecutorService service;

        /**
         * The NPC to move.
         */
        private final Ghost npc;

        /**
         * Creates a new task.
         *
         * @param service
         *            The service that executes the task.
         * @param npc
         *            The NPC to move.
         */
<span class="fc" id="L392">        NpcMoveTask(ScheduledExecutorService service, Ghost npc) {</span>
<span class="fc" id="L393">            this.service = service;</span>
<span class="fc" id="L394">            this.npc = npc;</span>
<span class="fc" id="L395">        }</span>

        @Override
        public void run() {
<span class="fc" id="L399">            Direction nextMove = npc.nextMove();</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">            if (nextMove != null) {</span>
<span class="fc" id="L401">                move(npc, nextMove);</span>
            }
<span class="fc" id="L403">            long interval = npc.getInterval();</span>
<span class="fc" id="L404">            service.schedule(this, interval, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L405">        }</span>
    }

    /**
     * An observer that will be notified when the level is won or lost.
     *
     * @author Jeroen Roosen
     */
    public interface LevelObserver {

        /**
         * The level has been won. Typically the level should be stopped when
         * this event is received.
         */
        void levelWon();

        /**
         * The level has been lost. Typically the level should be stopped when
         * this event is received.
         */
        void levelLost();
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>